---
layout: post
title: 'Backwards Compatibility: The Language Killer (Part 2)'
categories:
- Programming
tags: []
status: publish
type: post
published: true
meta:
  dsq_thread_id: '606605617'
author:
  login: air0day
  email: blog@air0day.com
  display_name: Rod Hilton
  first_name: Rod
  last_name: Hilton
---
<p>Why did I post such a long diatribe against taking the importance of backwards compatibility too far?  Because one thing angered me, and it "got me thinking."  This thinking stirred up into a rage, and I soon I forgot what I was angry about in the first place.  This happens a lot.  In fact, it's why I got this blog.</p>
<p>The thing that angered me is the Java Collections Interface.</p>
<p><!--more--></p>
<p>I've been working with JSPs at work lately.  Until recently, I've only had an academic understanding of JSP/Servlet technology, and an opportunity to work on a small project using J2EE came up, so I decided to use the opportunity to make my academic knowledge concrete.</p>
<p>To those who don't work with J2EE much, basically there are two ways you can write code in a JSP.  You can write it through scriptlets, which is basically just pure Java inside the JSP.  This is highly discouraged for a number of legitimate reasons I won't get into here.  Then there are tags, the preferred method.  Tags are like HTML tags, but processed by the server.  There are jsp element tags and custom tags, including the JSTL, a set of common tags that can be used.</p>
<p>Values are passed into tags a variety of ways, one of which is called Expression Language (EL).  EL allows access to the properties of a Java object through JavaBean naming conventions.  That means that some object, let's call it Fruit, will have properties "sweetness", "seeds", and "color" and so it will have 6 methods; getSweetness(), getSeeds(), getColor(), setSweetness, setSeeds, and setColor.  EL knows this naming convention, and allows you to refer to the properties of an object using it.  </p>
<p>So, if I had a Fruit called myFruit within scope in the JSP, I could print it's color in a page by saying: "The color is: ${myFruit.color}".  This knows, from ".color" to call the getColor() method.  There are also useBean tags and various other tags which allow you to basically get and set these bean properties.</p>
<p>Seems reasonable.  Keeping the property itself hidden inside the Fruit is good encapsulation, and the JavaBean naming convention is good for style.  </p>
<p>Okay.  So what if there were an object called "fruits" which was an instance of List from the Java Collections Interface.  That's cool, because you can access array members through brackets like you would expect.  Okay, what if I want to print the size?  </p>
<p>Uh oh.  There is no getSize() method for List.  the method for List is size().  That's odd, considering that the Sun style guide dictates that method names should be verbs.  getSize() would be appropriate, as would countSize() or fetchSize() or returnSize().  getSize() would be ideal, since it's a bean accessor method.  So why isn't it?</p>
<p><strong>Because Sun came up with all of these rules after the early version of Java was released, in which the List class method to get the size was called size()</strong></p>
<p>In order to maintain backwards-compatibility, they won't deprecate size() and replace it with getSize(), so what do you do to print the size of the List?  You don't.  You just don't do that.  At all!  You can have a servlet put an extra attribute in your request scope called "listSize" and reference that.  You could deal exclusively in a custom class that you write called <a href="http://www.phptr.com/articles/article.asp?p=30946&seqNum=8&rl=1">ListWrapper</a> which provides bean-style methods to a contained List.  Or you could use scriptlets and cheat.  But you can't, apparently, do this otherwise. </p>
<p>A completely basic functionality, seemingly totally impossible, for the sake of backwards-compatibility.</p>
<p>I'm hoping that I'm wrong, and that I discover a way to do this and I have to delete this post out of embarassment, but unless I've overlooked something, this is just how it is.  All because the language designers came up with a good idea too late, and don't make it right because it would sacrifice backwards-compatibility.</p>
