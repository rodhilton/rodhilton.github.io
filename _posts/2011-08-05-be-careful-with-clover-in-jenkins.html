---
layout: post
title: Be Careful With Clover in Jenkins
categories:
- Programming
tags:
- clover
- Continuous Integration
- jenkins
status: publish
type: post
published: true
meta:
  _syntaxhighlighter_encoded: '1'
  _edit_last: '1'
  dsq_thread_id: '607975839'
author:
  login: air0day
  email: blog@air0day.com
  display_name: Rod Hilton
  first_name: Rod
  last_name: Hilton
---
<p>We've got a common library used by a number of projects.  This library has it's own git repository and it's own job in Jenkins to build it. </p>
<p>One of the tasks of the Jenkins job is to, when the tests pass, copy the jar file artifact into a team-wide <a href="http://nexus.sonatype.org/">Nexus</a> instance, which is added as a repository in our other projects.</p>
<p>Lately I started having a problem where a new project that used this library was unable to run tests correctly - strange failures that seemed unrelated to any actual changes.  The culprit wound up being an unlikely source: Clover.</p>
<p><!--more--></p>
<p>The Jenkins Maven build goal for our library used to look like this:</p>
<p><code>clean compile test deploy</code></p>
<p>We wanted to start using <a href="http://www.atlassian.com/software/clover/">Clover</a> to track our test coverage of this library, so we installed it and altered the goal to this:</p>
<p><code>clean compile clover2:setup test clover2:aggregate clover2:clover deploy</code></p>
<p>This did what we expected, and we got to track our test coverage.  Something interesting happened later on, though.</p>
<p>Another project, which did not use clover at all, was using this library.  A strange error started popping up when trying to compile and run the tests for this new project:</p>
<p>[code gutter="false"]<br />
[CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (class java.lang.NoClassDefFoundError:com_cenqua_clover/CloverVersionInfo)</p>
<p>java.lang.NoClassDefFoundError: com_cenqua_clover/CoverageRecorder<br />
[/code]</p>
<p>This was really strange, since this new project didn't use clover at all.  Tracing the problem down to the class that generated this error, I found this in the decompiled stub generated by IntellJ when loading a class within the library from the open IntellIJ project that uses that library:</p>
<p>[java gutter="false"]<br />
public static class __CLR3_0_26b6bgqwyiqsv  {<br />
  public static final com_cenqua_clover.CoverageRecorder R;</p>
<p>  public __CLR3_0_26b6bgqwyiqsv() { /* compiled code */ }<br />
}<br />
[/java]</p>
<p>It turns out that when instrumenting clover, it actually compiles the classes somewhat differently, including some hooks for Clover (this seems to happen more in <code>enum</code>s).  When the jar file was being deployed, it was deploying the one with the Clover instrumentation.  Thus, when the new project downloaded it's dependencies from Nexus, it pulled a class with a dependency on Clover, but Clover was not on the classpath since this project didn't use it.</p>
<p>My solution was to split my job into two jobs.</p>
<p>The first job is focused on the health of the library, so it runs the tests, does the Clover information gathering, runs FindBugs, etc.  </p>
<p>The second job, the "deploy" job runs only when the first job completes successfully, then does a <code>clean compile deploy</code> without the Clover instrumentation.</p>
<p>This is the more correct methodology anyway, as it's closer to the Continuous Delivery pipeline advocated in Jez Humble's book, <a href="http://www.amazon.com/Continuous-Delivery-Deployment-Automation-Addison-Wesley/dp/0321601912">Continuous Delivery</a>, though it somewhat bothers me that the exact jar file being used for running tests is not the same jar file being deployed.</p>
