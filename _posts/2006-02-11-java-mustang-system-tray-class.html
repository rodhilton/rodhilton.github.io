---
layout: post
title: Java Mustang System Tray Class
categories:
- Programming
tags: []
status: publish
type: post
published: true
meta:
  dsq_thread_id: '606605626'
author:
  login: air0day
  email: blog@air0day.com
  display_name: Rod Hilton
  first_name: Rod
  last_name: Hilton
---
<p>It looks like Sun is adding a feature to Java 6 (Mustang) that will surely make a number of people very happy: <a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/mustang/systemtray/">the ability to add an icon to the system tray</a>.</p>
<p>This single feature serves to illustrate the tricky predicament Sun is in with Java as a desktop development language.</p>
<p><!--more--></p>
<p>Java faces a number of challenges.  First and foremost, there are the largely fallacious arguments that Java is slow.  This is a gross oversimplification.  The way Java works, the virtual machine must first load into memory.  Then Java needs to load the libraries needed and start executing.  As Java applications run, they are analyzed for bottlenecks and optimized.  Java bytecode is compiled further into system code through the Just-In-Time compiler.  The longer an application runs, the faster it gets because more of the code gets JIT compiled, and more of it gets analyzed and optimized for maximum efficiency.</p>
<p>This is why Java is very good for servers.  Generally a server will start, load what it needs, and serve requests for huge stretches of time.  The code being executed is optimized, so the server tends to get faster and more responsive as it goes on.  When an app runs for a long time, the constant-time loading of the jvm is dwarfed and insignificant.  A lot of benchmarks have shown that for long-running apps, Java actually outperforms C, primarily because it can be dynamically optimized (rather than statically optimized at compile-time) and because memory management can be done opportunistically, rather than by programmer-mandated mallocs and frees.</p>
<p>This is not the case with desktop software.  When you run an application on your desktop, you tend to run it, use it, and close it.  That means that the startup time of the jvm is NOT dwarfed by your overall run-time, and you don't give the jvm a chance to optimize the code.  This is why people hate running java applications on their desktops.  </p>
<p>This is not to say that Java has no place on the desktop.  There are a great number of popular Java-based desktop applications.  <a href="http://azureus.sourceforge.net/">Azureus</a> is a very popular BitTorrent client.  <a href="http://www.eclipse.org/">Eclipse</a> is a fantastic IDE for a wide variety of languages.  I use it for Java and ColdFusion at work, PHP at home.  <a href="http://www.openoffice.org/">OpenOffice.org</a> has been very successful, and a great deal of it is written in Java.  But all of these programs have two things in common, which you will notice if you use them often: they take a very long time to start up, and you tend to leave them open for a long time.  Azureus stays open for days while you download all of that porn you found.  OpenOffice.org and Eclipse are both large applications that you leave open while you perform time-consuming work, such as developing an application or writing a document.</p>
<p>Imagine if your web browser took as long to start as OpenOffice.  Imagine if notepad took that long.  Or your file manager.  These are apps you run for a quick task, then tend to close. </p>
<p>Java has a lot of hurdles to overcome to become popular for the desktop (including pure stigma).  The more people make the "Java==Slow" association in their minds, the less willing they are to use Java in other environments, such as servers or mobile phones. </p>
<p>The fact that Java can't do a lot of things in Windows is also a problem.  Since Windows is the most common OS, Java apps will tend to be compared to C++ Windows apps, which are typically much faster and have full access to the Win32 API.  When Java can't do something like create a system tray icon, it makes matters far worse.</p>
<p>The Java GUI toolkits were designed in a pretty specific way, and in much the same way as SWT.  Basically, the toolkits take a "lowest common denominator" approach.  If a feature is present on all of the operating environments in which a Java app runs, it is included in the toolkit.  Otherwise, it is not included.  This is why Java cannot currently make System Tray icons.  This decision in toolkit design was made so that Java code would be portable to any OS, which is a major Java selling point.  Swing isn't quite as restrictive as AWT (or even SWT) because it doesn't try to use the look and feel of the underlying OS, but it's still incapable of performing tasks outside of the Java JVM, for the most part.</p>
<p>The decision to include SystemTray functionality is a big one.  Not every OS has such a thing, so how will Java handle it?</p>
<blockquote><p>If the system tray is not present or supported on this platform, the isSupported() method returns false. If the application attempts to call getSystemTray() in such a case, the method will throw a java.lang.UnsupportedOperationException.</p></blockquote>
<p>Indeed, you must check if the OS supports it, and it throws a unchecked exception if the OS does not.  This is an important move by Sun because it means they are, at least partially, DROPPING the "lowest common denominator" approach to the toolkits.  This is an obvious attempt to grab a greater portion of the desktop market, but what does it mean for Java?</p>
<p>Like it or hate it, Sun has stuck by its design decision pretty well during Java's life.  They are now only partially committed to the ideal.  This means when someone submits a request for enhancement like "I want to make my window flash in the taskbar" or "I want to customize the classname of my window as it appears in Windows" or "I want access to the list of OS window handles so I can send keys/messages to other applications like a native Windows app can do," Sun will have a hard time arguing the point down, since they caved in the SystemTray instance.  </p>
<p>If you've ever tried to make a Java application so that only one instance of it can run at a time (very common), you know that the "accepted" way of doing this is trying to open a specially reserved network port and keep it open while the app runs.  When a second instance of the app runs, it can't get the port open (since it's in use), and quits.  In a native windows app, you can check if the app's classname is registered in Windows already - in fact, you can even send messages to the app before exiting.  This is why you can open mp3 files and have them all go into the same instance of Winamp.  When the new Winamp associated with .mp3 files runs, it notices that Winamp is already running, and sends its commandline parameters to the existing instance, which then adds the files to its own queue.  This is the kind of thing Java application programmers would love to do, so when they ask for it to be added, what leg does Sun have to stand on when saying "no".  If they brought out the lowest-common-denominator issue and how unportable the code would be, now programmers can say "but SystemTray!"</p>
<p>The inclusion of SystemTray represents to me a feature that I <strong>am</strong> genuinely excited to see in Java, but it also represents compromising the design ideal set for the AWT toolkit.  I can't help but wonder why Sun doesn't release a Windows-only toolkit that uses native widgets for everything, and one for OS X, Gnome, and so on. </p>
<p>Sure, this goes against the "Write One, Run Anywhere" approach, but the truth is that there are mountains of Java code out there that use Runtime.getRuntime().exec() or even check System for the OS and exit if it isn't the OS the app was intended for.  While this code does go against the spirit of Java, there is no denying that some people enjoy Java for the language or for familiarity rather than for it's goals and ideals.  If someone learned Java for a class or something and wants to write a Windows app, they will be far more likely to write a Windows-specific app in Java than to go learn C++, if only because they already know Java.  If Sun is willing to go this far, why not make exchangable OS-specific toolkits available that use native API calls?  </p>
<p>While code SHOULD be multiplatform if possible, sometimes it just isn't possible, and it's those cases that hurts Java's appeal to the desktop environment.  That's why they are adding SystemTray, to get back some of the market share on the desktop.  So my question is this: why do it half-assed?</p>
