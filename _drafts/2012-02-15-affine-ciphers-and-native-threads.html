---
layout: post
title: Affine Ciphers and Native Threads
categories:
- Life
tags: []
status: draft
type: post
published: false
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
author:
  login: air0day
  email: blog@air0day.com
  display_name: Rod Hilton
  first_name: Rod
  last_name: Hilton
---
<p>My Cryptography professor was talking about Affine ciphers on Tuesday.  Really quickly, an Affine cipher works pretty simply:</p>
<ul>
<li>Define a pair, $$(\alpha, \beta)$$ where $$\alpha, \beta \in \mathbb{Z}$$ and $$\gcd(\alpha, 26) == 1$$.</li>
<li>Define an encryption function $$E$$ that takes an $$x$$ where $$0 \le x < 26$$: $$E(x) = \alpha \times x + \beta \mod 26$$.</li>
<li>For each character $$c$$ in the plaintext using numerical mapping $$A=0, B=1,..., Z=25$$, perform $$E(c)$$ to get the ciphertext</li>
</ul>
<p><!--<br />
[ruby]<br />
require 'rational'</p>
<p>NUM_THREADS = 7</p>
<p>@alphabet = ('A'..'Z').to_a  #The letters we're using<br />
@rev_alphabet = Hash[*@alphabet.zip((0..@alphabet.length-1).to_a).flatten]  #Reverse hash lookup. {&quot;A&quot;=&gt;0, &quot;B&quot;=&gt;1, etc}</p>
<p>@coprimes = 1.upto(@alphabet.length-1).find_all{|c| @alphabet.length.gcd(c) == 1 } #Numbers coprime with 26<br />
@dictionary = IO.readlines(&quot;2of4brif.txt&quot;).map { |line| line.strip.upcase }.sort  #All english words in uppercase</p>
<p>def encrypt(word, alpha, beta)<br />
  word.upcase.split(//).collect{|letter| @alphabet[ ( alpha * @rev_alphabet[letter] + beta ) % 26]}.join<br />
end</p>
<p>def count_encrypted_words(alpha, beta)<br />
  count = 0<br />
  File.open(&quot;#{alpha}x + #{beta}.txt&quot;, 'w')  do |f|<br />
    @dictionary.each do |word|<br />
      encrypted=encrypt(word, alpha, beta)<br />
      if @dictionary.include?(encrypted)<br />
        f.write(&quot;#{word} =&gt; #{encrypted}\n&quot;)<br />
        count = count +1<br />
      end<br />
    end<br />
  end<br />
  count<br />
end</p>
<p>def chunk_array(array, pieces=2)<br />
  len = array.length;<br />
  mid = (len/pieces)<br />
  chunks = []<br />
  start = 0<br />
  1.upto(pieces) do |i|<br />
    last = start+mid<br />
    last = last-1 unless len%pieces &gt;= i<br />
    chunks &lt;&lt; array[start..last] || []<br />
    start = last+1<br />
  end<br />
  chunks<br />
end</p>
<p>threads = []<br />
affines = []</p>
<p>@coprimes.each do |alpha|<br />
  0.upto(@alphabet.length-1) do |beta|<br />
    affines &lt;&lt; {:alpha=&gt;alpha, :beta=&gt;beta}<br />
  end<br />
end</p>
<p>#Break array of affine pairs into NUM_THREADS chunks and spawn a thread for each chunk<br />
chunk_array(affines, NUM_THREADS).each do |chunk|<br />
  puts &quot;Creating thread to solve #{chunk.length} affines&quot;<br />
  threads &lt;&lt; Thread.new do<br />
  chunk.each do |affines|<br />
      alpha = affines[:alpha]<br />
      beta = affines[:beta]<br />
      count = count_encrypted_words(alpha, beta)<br />
      puts &quot;#{sprintf('%2.2sx + %2.2s', alpha, beta)} ===&gt; #{count} words&quot;<br />
    end<br />
  end<br />
end</p>
<p>#Give all threads enough time to complete<br />
threads.each do |thread|<br />
  thread.join<br />
end<br />
[/ruby]<br />
--></p>
